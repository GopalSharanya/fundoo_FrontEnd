var port = process.REDIS_PORT
	, host =  process.REDIS_HOST;

var redis = require('redis')
	, utils = require('./utils')
	, EventEmitter = require('events').EventEmitter
	, rc = redis.createClient(port, host);

/*
 * General Arguments in method signatures:
 * name - refers to the name of the object, akin to it's class name
 * id - the id of the object to be manipulated
 * properties - an object containing keys & values for storage
 * callback - the function to be called when the process is complete
 *
 */

var Ninjazord = function (options) {
	EventEmitter.call(this);
};

utils.extend( Ninjazord.prototype, {
	__proto__ : EventEmitter.prototype,
	// cb just checks to make sure callback is a
	// function & passes it along.
	cb : utils.cb,
	// Expose the client.
	client : rc,
	/* ------ * Prefix * ------ */
	setPrefix : function(newPrefix){
		if (typeof newPrefix === 'string') this.prefix = newPrefix;
		return this;
	},
	getPrefix : function() { return this.prefix; },
	prefix : 'bm.',
	// sanitize a value returned from the db;
	sanitize : function (val) {
			if (val === 'true') { val = true; }
			else if (val === 'false') { val = false; }
			//else if ( isNaN(parseFloat(val,10)) ) { val = parseFloat(num); }
			return val;
	},

	/* ------ * Objects * ------ */
	createObject : function (name, properties, callback) {
		var self = this;
		if (!name || !properties){
			self.cb(false, callback);
			//throw console.error('name || properties not defined for createObject');
		}

		// Add this object to the list of all objects.
		rc.sadd(self.prefix + 'objects', name);
		rc.incr(self.prefix + name + '.new',function (err, id){
			if (err) return self._error('incr',err);
			properties.id = id;
			properties.created = utils.newDate();
			properties.updated = properties.created;
			rc.sadd(self.prefix + name + '.all', id, function (err,res){
				self.setHash(name + '.' + id, properties, function(res){
						self.cb(properties, callback);
				});
			});
		});
		return this;
	},
	// @todo - merge this with create object,
	// instead just checking for a supplied ID argument
	// in properties.
	createObjectWithExternalId : function(name, id, properties, callback){
		var self = this;
		properties.id = id;
		properties.created = utils.newDate();
		properties.updated = properties.created;

		self.incr(name + '.count', function (count){
			rc.sadd(self.prefix + name + '.all', id, function(err,res){
				self.setHash(name + '.' + id, properties, function(res){
					self.cb(properties, callback);
				});
			});
		});
		return this;
	},
	readObject : function (name, id, callback) {
		var self = this;
		self.getHash(name + '.' + id, function(object){
			// make sure the object id is returned as a number.
			object.id = parseInt(object.id, 10);
			self.cb(object, callback);
		});
		return this;
	},
	updateObject : function(name, id, properties, callback) {
		var self = this;
		properties.updated = utils.newDate();
		self.setHash(name + '.' + id, properties, function(res){
			self.cb(res, callback);
		});
		return this;
	},
	deleteObject : function (name, id, callback) {
		// @todo check this.
		var self = this;
		rc.srem(self.prefix + name + '.all', id,function(err,res){
			if (err) return self._error('objectExists',err);
			rc.del(self.prefix + name + '.' + id,function(err,res){
				if (err) return self._error('objectExists',err);
				self.cb((res===1),callback);
			});
		});
		return this;
	},
	objectExists : function (name, id, callback) {
		var self = this;
		rc.sismember(self.prefix + name + '.all', id, function(err,exists){
			if (err) return self._error('objectExists',err);
			self.cb((exists===1),callback);
		});
		return this;
	},

	/* ------ * Hashes * ------ */
	sanitizeHash : function (hash) {
		var num;
		for (var attr in hash){
			hash[attr] = this.sanitize(hash[attr]);
		}
		return hash;
	},
	setHash : function (name, obj, callback) {
		var self = this;
		rc.hmset(self.prefix + name, obj, function (err, res){
			if (err) return self._error('setHash',err);
			self.cb((res==='OK'),callback);
		});
	},
	getHash : function (name, key, callback) {
		var self = this;
		if (arguments.length === 3)
			rc.hget(self.prefix + name, key, function(err, hash){
				if (err) return self._error('getHash',err);

				self.cb(hash, callback);
			});
		else {
			callback = key;
			rc.hgetall(self.prefix + name, function (err, hash){
				if (err) return self._error('getHash',err);
				// getHash for an object that doesn't exist returns an
				// empty object. This ensures it returns false;
				if (utils.objectSize(hash) === -1) self.cb(false, callback);
				else self.cb( self.sanitizeHash(hash), callback);
			});
		}
	},
	hashDelete : function (name, key, callback) {
		var self = this;
		if (arguments.length === 3)
			rc.hdel(self.prefix + name, key, function(err,res){
				if (err) return self._error('hashDelete',err);
				self.cb((res===1),callback);
			});
		else {
			callback = key;
			rc.del(self.prefix + name, function(err,res){
				if (err) return self._error('hashDelete',err);
				self.cb((res===1),callback);
			});
		}
	},
	hashExists : function (name, key, callback) {
		var self = this;
		if (arguments.length === 3)
			rc.hexists(self.prefix + name, key, function(err,res){
				if (err) return self._error('hashExists',err);
				self.cb((res===1), callback);
			});
		else {
			callback = key;
			self.exists(name,callback);
		}
	},

	/* ------ * Sets * ------ */
	setAdd : function(name,value,callback) {
		var self = this;
		rc.sadd(self.prefix + name, value, function(err,res){
			if (err) return self._error('setAdd',err);
			self.cb((res===1),callback);
		});
	},
	setRemove : function(name,value,callback){
		var self = this;
		rc.srem(self.prefix + name, value, function(err,res){
			if (err) return self._error('setRemove',err);
			self.cb((res === 1), callback);
		});
	},
	setMembers : function(name,callback){
		var self = this;
		rc.smembers(self.prefix + name, function(err,members){
			if (err) return self._error('setMembers',err);
			self.cb(members, callback);
		});
	},
	setLength : function (name, callback) {
		var self = this;
		rc.scard(self.prefix + name, function(err,length){
			if (err) return self._error('setLength',err);
			self.cb(length, callback);
		});
	},
	setIsMember : function(name,value,callback){
		var self = this;
		rc.sismember(self.prefix + name, value, function(err,res){
			if (err) return self._error('setIsMember',err);
			self.cb((res === 1), callback);
		});
	},

	/* ------ * Sorted Sets * ------ */
	sortedSetAdd : function(name,score,value,callback) {
		var self = this;
		rc.zadd(self.prefix + name,score,value,function(err,res){
			if (err) return self._error('sortedSetAdd',err);
			self.cb((res===1), callback);
		});
		return this;
	},
	sortedSetRemove : function(name,value,callback) {
		var self = this;
		rc.zrem(self.prefix + name,value,function(err,res){
			if (err) return self._error('sortedSetRemove',err);
			self.cb((res===1), callback);
		});
		return this;
	},
	sortedSetRange : function(name, start, stop, withScores, callback){
		var self = this;
		if (arguments.length === 5)
			rc.zrange(self.prefix + name, start, stop, 'WITHSCORES', function (err,range){
				if (err) return self._error('sortedSetRange',err);
				self.cb(range, callback);
			});
		else {
			callback = withScores;
			rc.zrange(self.prefix + name, start, stop, function (err,range){
				if (err) return self._error('sortedSetRange',err);
				self.cb(range, callback);
			});
		}
		return this;
	},
	sortedSetLength : function (name,callback) {
		var self = this;
		rc.zcard(self.prefix + name, function(err, count){
			if (err) return self._error('sortedSetCount',err);
			self.cb(count, callback);
		});
		return this;
	},

	/* ------ * Basic Methods * ------ */
	set : function (name, value, callback) {
		var self = this;
		rc.set(self.prefix + name, value, function(err,res){
			if (err) return self._error('set',err);
			self.cb((res==='OK'), callback);
		});
	},
	get : function (name, callback) {
		var self = this;
		rc.get(self.prefix + name, function(err,value){
			if (err) return self._error('get',err);
			if (value === undefined || value === null) value = false;
			self.cb(value, callback);
		});
	},
	del : function (name, callback) {
		var self = this;
		rc.del(self.prefix + name, function(err,res) {
			if (err) return self._error('del',err);
			self.cb((res === 1), callback);
		});
	},
	incr : function (name, callback) {
		var self = this;
		rc.incr(self.prefix + name, function (err, index){
			if (err) return self._error('incr',err);
			self.cb(index, callback);
		});
	},
	exists : function (name, callback) {
		var self = this;
		rc.exists(self.prefix + name, function (err, res) {
			if (err) return self._error('exists',err);
			self.cb((res === 1), callback);
		});
	},

	/* ------ * Error Handling * ------ */
	_error : function (command, error) {
		console.log('ERROR - Redis %s command: %s', command, error);
		return false;
	},

	/* ------ * Utility DB Manipulation Methods * ------ */
	/* ****** * NOT INTENDED FOR PRODUCTION USE * ****** */
	nukeNamespace: function (nameSpace, callback) {
		rc.keys(nameSpace + '*',function(err,res){
			var count = res.length;
			if (count) {
				res.forEach(function(key){
					rc.del(key,function(err,res){
						if(--count === 0) callback();
					});
				});
			} else callback();
		});
	}
});

module.exports = new Ninjazord();